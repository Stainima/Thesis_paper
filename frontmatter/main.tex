%%%%%%%% TITLE PAGE %%%%%%%%%%%%
\newgeometry{
    inner=2.5cm,
    outer=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}
\onehalfspacing
\input{frontmatter/title_page}
\restoregeometry
\onehalfspacing

%%%%%% Clarence from %%%%%%%%%%
\includepdf{pdfiles/Clearence_form.pdf}

%%%%%%%%%%%%%%%% COPYRIGHT %%%%%%%%%%%%%%%%%%%%
\clearpage\null\thispagestyle{empty}
\begin{center}
    \vspace*{\fill}
    
    % \textcopyright \ 2025 Sulav Malla \\
    % All Rights Reserved\\ \vspace{1em}
    
    No part of this work may be reproduced, stored in a retrieval system, or transmitted \\
    in any form or by any means, electronic, mechanical, photocopying, or otherwise, \\
    without the prior permission of the author or The University of Sydney.
\end{center}

%%%%%%%%%%%%%%%% ABSTRACT %%%%%%%%%%%%%%%%%%%%
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
Knowing the source code of a program greatly aids program comprehension, testing techniques such as fuzzing, optimisation, and debugging. However, due to various restrictions and other external factors, accessing source code is often not possible. To address this limitation, recent research has focused on inferring input grammars and execution behaviour directly from valid program inputs. The ARVADA algorithm, developed by Lemieux C. and Kulkarni N. at UCB in 2021, is a black-box approach designed to infer the grammar of a program using only valid inputs and a black-box oracle.

Motivated by the lack of formal guarantees and concerns about the selectiveness of the original study, this thesis attempts to re-implement the ARVADA algorithm in a clean-room environment using the C programming language. Although a complete implementation was not achieved, this paper presents a partial implementation of ARVADA algorithm in C with improvements of the function MergeAllValid, and highlights the challenges faced and insights gained during the re-implementation. These include the inherent complexity of ARVADA, the difficulty of implementing such an algorithm in C, and the limited clarity and weakeness in the explanation provided in the original paper.

\newpage
\chapter{Statement of Achievements}

The major achievements of this paper include the following:
\begin{itemize}
    \item Partial re-implementation of ARVADA in a clean room environment in C, with improvements. The improvements include optimisation of MergeAllValid.
    \item Identification of areas in the original paper that were poorly explained, making the study difficult to reproduce.
\end{itemize}


\newpage
\chapter{Acknowledgement}

I would like to acknowledge my supervisors for this project.
Firstly, I would like to thank \textbf{Dr.~Rahul Gopinath} for providing me with the opportunity to undertake this project and for his continued support when I needed it. 
I would also like to thank \textbf{Dr.~Yash Shrivastava} for agreeing to be my ECE supervisor.  

Additionally, I wish to express my gratitude to my friends and family for their constant support, patience, and understanding throughout this.  
There were many high moments, low moments, and times when I felt completely stuck, but at the end am very gald to have taken this project.  
\\[1.5em]
\noindent\textbf{Thank you, Dr.~Rahul Gopinath and Dr.~Yash Shrivastava.}

%%%%%%%%%%%%%%%% Table of Contents %%%%%%%%%%%%%%%%%%%%
\newpage\thispagestyle{empty}
\tableofcontents
\listoffigures

\chapter{Glossary}
\begin{description}

\item[Grammar] A set of production rules defining how valid strings or sentences in a language are constructed.

\item[Context-Free Grammar (CFG)] A grammar where each rule replaces a single non-terminal with a string of terminals and/or non-terminals.

\item[ARVADA] An algorithm that infers context-free grammars from valid inputs using a black-box oracle through bubbling and merging operations.

\item[GLADE] A grammar inference algorithm and predecessor to ARVADA, used as a benchmark for comparison.

\item[Inference] The process of deriving or learning rules or structures from observed data. In this thesis, it refers to grammar inference — the automatic discovery of a program’s input grammar using algorithms such as ARVADA.

\item[Oracle] A black-box function that determines whether a given input string is valid according to a program’s grammar.

\item[Node] A structural element of a parse tree representing either a terminal or non-terminal symbol.

\item[Memory Management] The manual process of dynamically allocating and freeing memory in C to store and manipulate parse trees.

\item[Fuzzing] A software testing method that generates random or semi-random inputs to discover vulnerabilities or unexpected behaviour.

\item[Black-box Setting] A testing or inference environment where the internal structure of the system is unknown, and only input-output behaviour is observable.

\item[TREEVADA] A deterministic and faster successor to ARVADA that improves pre-tokenisation and bubble ranking heuristics.

\item[KEDAVRA] An incremental grammar inference algorithm improving upon TREEVADA in accuracy, readability, and runtime efficiency.

\item[NATGI] An LLM-guided grammar inference framework extending TREEVADA for more readable and natural grammar generation.

\item[Clean-room Implementation] A re-implementation performed without referencing the original codebase, relying solely on the published paper.

\item[Reproducibility] The ability of an experiment or study to be replicated with consistent results under the same conditions.

\end{description}

