\chapter{Appendix}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        stepnumber=1,
        basicstyle = \tiny,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
    Node *build_basic_node(){

        Node * node = malloc(sizeof(Node));
        node->parent = NULL;
        node->capacity = 0;
        node->character = '\0';
        node-> t= -1;
        node->num_child = 0;
        node->pos = -1;
        node->children = NULL;
        return node;
    }


    \end{lstlisting}
\caption{Code for building a basic node}
\label{fig:buildBasicNode}
\end{figure}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        stepnumber=1,
        basicstyle = \tiny,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]

    // Function that checks Node capacity and count.
    void check_nodes_capacity(Nodes *nodes){

        // If number for Node's is less than current capacity, return.
        if(nodes->capacity > nodes->count){
            return;
        }

        // If number of childern has reached capacity, update cap.
        int cur_cap = nodes->capacity;
        nodes->capacity = (cur_cap + (cur_cap/2) + 1);
        void *new_space = realloc(nodes->rootNodes,nodes->capacity * sizeof(Node*));
        if(errno == ENOMEM || new_space == NULL){
            fprintf(stderr, "Error increasing the capicty of nodes.");
            return;
        }
        nodes->rootNodes= new_space;

    }

    // Fucntion that checks Node capacity and num_child.
    void check_node_capacity(Node *node){

        if(node->capacity > node->num_child){
            return;
        }

        // If number for Node's is less than current capacity, return.
        int cur_cap = node->capacity;
        node->capacity = (cur_cap + (cur_cap/2) + 1);
        void *new_space = realloc(node->children,node->capacity * sizeof(Node*));
        if(errno == ENOMEM || new_space == NULL){
            fprintf(stderr, "Error increasing the capicty of nodes.");
            return;
        }
        node->children= new_space;

    }

    \end{lstlisting}
\caption{Code for changing list capacities appropriately}
\label{fig:capacityChangeCode}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        stepnumber=1,
        basicstyle = \tiny,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
        // Function to free all the nodes given a root Node
        void free_tree(Node *root){

            // dfs, freeing children nodes first
            if (root->num_child > 0){
                for( int i = 0; i < root->num_child; i++){
                    free_tree(root->children[i]);
                }
                free(root->children);
            }
            free(root);
        }
    \end{lstlisting}
\caption{Code for freeing tree given a root node}
\label{fig:freeNodes}
\end{figure}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
void pre_tokenise(Node* root){

    // Flags to count contigious seuqences.
    int sequence_begun = 0;
    int sequence_length = 0;
    // class 1 = Whitespaces
    // class 2 = Uppercase
    // class 3 = Lowercase
    // class 4 = Digits

    // Set basic node with a list up.
    // parent and children of the node assigned in progress.
    Node *tmp = build_basic_node_with_list();
    
    // num of child and parent save in a local var,
    // helps later for memory management
    int cur_children_num = root->num_child;
    Node ** cur_children = root->children;
    root->capacity = 1;
    root->num_child = 0;
    root->children= calloc(root->capacity, sizeof(Node*));


    for( int i = 0; i < cur_children_num; i++){

        Node * cur_node= cur_children[i];
        // Current character is a whiteSpace
        if(cur_node->character == ' '){
            check_and_tokenise(1, &sequence_length, &sequence_begun, &tmp, cur_node);

        // Current character is an uppercase character
        }else if(isupper(cur_node->character)){
            check_and_tokenise(2, &sequence_length, &sequence_begun, &tmp, cur_node);

        // Current character is a lower character.
        }else if(islower(cur_node->character)){
            check_and_tokenise(3, &sequence_length, &sequence_begun, &tmp, cur_node);

        // Current character is a digit.
        }else if(isdigit(cur_node->character)){
            check_and_tokenise(4, &sequence_length, &sequence_begun, &tmp, cur_node);

        // Current character is punctuation
        }else{

            // sequence of size 1 in progress, remove warpper
            if(sequence_length == 1){
                root->children[root->num_child] = tmp->children[0];
                root->num_child ++;
                check_node_capacity(root);
                tmp->num_child = 0;
                tmp->children[0] = NULL;
                free((tmp)->children);
                free_tree(tmp);

            }else if(sequence_length >1 ){
                // multi character sequence, close and attach
                tmp->parent = tmp->children[0]->parent;
                (*tid) ++;
                tmp->t_label = *tid;

                Node *p = cur_node->parent;
                if (p) {
                    p->children[p->num_child] = tmp;
                    (p->num_child)++;
                    check_node_capacity(p);
                }

            }

            tmp = build_basic_node_with_list();
            root->children[root->num_child] = cur_node;
            root->num_child++;
            check_node_capacity(root);
            sequence_begun = 0;
            sequence_length = 0;
        }
    }

    // End of loop is reached, deal with the left over unclosed sequence
    if(sequence_length == 1){
        root->children[root->num_child] = tmp->children[0];
        root->num_child ++;
        check_node_capacity(root);
        tmp->num_child = 0;
        tmp->children[0] = NULL;
        free((tmp)->children);
        free_tree(tmp);
    }else if(sequence_length == 0){
        free_tree(tmp);
    } else  {
        root->children[root->num_child] = tmp;
        root->num_child ++;
        tmp->parent = root;
        (*tid) ++;
        tmp->t_label = *tid;
        check_node_capacity(root);
    }
    free(cur_children);
}


    \end{lstlisting}
\caption{Pre-tokeniser code}
\label{fig:Pre_tokeniser}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
    void check_and_tokenise(int cur_class, int *sequence_length, int *sequence_begun, Node **tmp, Node *cur_node){

    // A sequence of the same class as currnet node is in progress.
    if (*sequence_begun == cur_class && *sequence_length > 0){

        // Because the parent of the first child is never assigned,
        // this is done to deal with cases where a sequence of just
        // length 1 is found.
        if (*sequence_length == 1 && (*tmp)->num_child > 0) {
            (*tmp)->children[0]->parent = *tmp;
        }
        // Assigning the current node to tmp,
        // increase sequence number.
        cur_node->parent = *tmp;
        (*tmp)->children[(*tmp)->num_child]= cur_node;
        (*tmp)->num_child ++;
        check_node_capacity(*tmp);
        (*sequence_length)++;

    // no sequence or a different sequence has begun
    }else{

        // different sequence of length 1 is in progress.
        if(*sequence_length == 1){
            // previous sequence was just one node, discard wrapper
            Node *p = cur_node->parent;
            if (p) {
                p->children[p->num_child] = (*tmp)->children[0];
                (p->num_child)++;
                check_node_capacity(p);
                }

            (*tmp)->num_child = 0;
            (*tmp)->children[0] = NULL;
            free((*tmp)->children);
            free_tree(*tmp);
            *tmp= build_basic_node_with_list();
            (*tmp)->children[(*tmp)->num_child] = cur_node;
            (*tmp)->num_child ++;
            check_node_capacity(*tmp);

        // different sequence of length greater than 1 has begun.
        }else if(*sequence_length > 1){
            // finalise previous multi-node sequence
            (*tmp)->parent = (*tmp)->children[0]->parent;
            *tid = *tid + 1;
            (*tmp)->t_label = *tid;


            Node *p = cur_node->parent;
            if (p) {
                p->children[p->num_child] = *tmp;
                (p->num_child)++;
                check_node_capacity(p);
            }

            *tmp = build_basic_node_with_list();
            (*tmp)->children[(*tmp)->num_child] = cur_node;
            (*tmp)->num_child ++;
            check_node_capacity(*tmp);
            *sequence_length = 1;

        // no sequence in progress, assign this node as first node,
        // and begin the sequence.
        }else if(*sequence_begun == 0) {
            (*tmp)->children[(*tmp)->num_child] = cur_node;
            (*tmp)->num_child ++;
            check_node_capacity(*tmp);
            *sequence_length = 1;
        }
    }
    *sequence_begun = cur_class;
}

    \end{lstlisting}
\caption{Pre-tokenisation helper code}
\label{fig:pre_tokenise helper}
\end{figure}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
void merge_all_valid(Node *root, Nodes *all_trees){

    // Go through the list 1 once
    for( int i = 0; i < root->num_child; i++){

        // Skip White spaces
        if(root->children[i]->character == ' '){
            continue;
        }

        // Go through the list number 2 for perms
        for ( int j = i + 1; j < root->num_child; j++){

            // Skip White spaces
            if(root->children[j]->character == ' '){
                continue;
            }

            // concatenate ta and tb to get strings
            char *buffer_ta = calloc(1, sizeof(char));
            concatenate(root->children[i], &buffer_ta);
            char *buffer_tb = calloc(1, sizeof(char));
            concatenate(root->children[j], &buffer_tb);

            // if both t_a and t_b concatneate to the same string
            // Merge (change labels ) if they are non-terminals or non-white space.
            if(strcmp(buffer_ta,buffer_tb) == 0){
                merge_same_node(root->children[i], root->children[j], i, j, root);
                //printf("Comp: %s, %d\n", buffer_ta, root->children[i]->t_label);
                free(buffer_ta);
                free(buffer_tb);
                continue;
            }

            free(buffer_ta);
            free(buffer_tb);


        }

    }

    for( int i = 0; i < root->num_child; i++){

        // Skip White spaces
        if(root->children[i]->character == ' '){
            continue;
        }

        // Go through the list number 2 for perms
        for ( int j = i + 1; j < root->num_child; j++){

            // Skip White spaces
            if(root->children[j]->character == ' '){
                continue;
            }

            // If 2 nodes have the same non-negative label
            // means the node has already been merged. Skip.
            if((root->children[i]->t_label == root->children[j]->t_label) && (root->children[i]->t_label > -1)){
                continue;
            }
            // t_a and t_b concatenate to different strings.
            // Now perform a more extensive checl
            int *res = calloc(1, sizeof(int));
            *res = 1;
            for( int i = 0; i < all_trees->count; i++){

                Node *dup_tree = duplicate_tree(all_trees->rootNodes[i]);
                rigorous_replacement_check(root->children[i], root->children[j], dup_tree, 0, res);
            }

            if( *res ){
                for( int i = 0; i < all_trees->count; i++){

                    Node *dup_tree = duplicate_tree(all_trees->rootNodes[i]);
                    rigorous_replacement_check(root->children[i], root->children[j], dup_tree, 0, res);
                }
            }

            if(*res){
                merge(root->children[i], root->children[j], root, i, j);
            }

            free(res);


        }

    }

}



    \end{lstlisting}
\caption{Merge All valid function code}
\label{fig:MergeAllValid function code}
\end{figure}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
    void concatenate(Node *root, char** buffer){

        if(root->t_label == -1){
            size_t len = strlen(*buffer);
            char *new_space = realloc(*buffer, (len + 2) * sizeof(char));
            new_space[len] = root->character;
            new_space[len + 1] = '\0';
            *buffer = new_space;
            return;
        }

        for( int i = 0; i < root->num_child; i++){
            concatenate(root->children[i], buffer);

        }
    }
    \end{lstlisting}
\caption{String concatenate function}
\label{fig:Stirng Concatenate}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
void merge_same_node(Node *ta, Node *tb, int i , int j, Node *root){

    // Check the labels have already been merge
    // cases where theere are 3 of the same kind
    if((ta->t_label == tb->t_label) && (ta->t_label > 0)){
        return;
    }

    // if we are trying to merge 2 leaf nodes,
    // This is assuming pre-tokenisation.
    if(ta->t_label == -1 || tb->t_label == -1){

        // Create and link the nodes.
        // Only create the Link node if a link
        // intermediate node does not exist yet.
        // This accounts for when there are multiple of the same
        // leaf node.
        if(root->children[i]->t_label == -1){

            Node *ta_label = build_basic_node_with_list();
            (*tid)++;
            ta_label ->t_label = *tid;
            ta_label->parent = ta->parent;
            ta_label->children[0] = ta;
            (ta_label->num_child) ++;
            root->children[i] = ta_label;
            ta->parent = ta_label;

        }
        Node *tb_label = build_basic_node_with_list();
        tb_label ->t_label = *tid;
        tb_label->parent = tb->parent;
        tb_label->children[0] = tb;
        (tb_label->num_child) ++;
        root->children[j] = tb_label;
        tb->parent = tb_label;
        return;
    }

    // if 2 non-terminals are given
    // converge by changing the both t-label to
    // min (ta->t_label, tb->t__label)
    if(ta->t_label < tb->t_label){
        tb->t_label = ta->t_label;
    } else {
        ta->t_label = tb->t_label;
    }
    return;
}
   \end{lstlisting}
\caption{Merging same nodes}
\label{fig:Merging Same nodes}
\end{figure}


\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
    void merge(Node *node_1, Node *node_2, Node *root, int i, int j){


    // Add an intermediate label node
    // if either of the nodes are leaf nodes.
    if(node_1->t_label == -1){
        Node *inter_node= build_basic_node_with_list();
        (*tid)++;
        inter_node->t_label = *tid;
        inter_node->parent = node_1->parent;
        inter_node->children[0] = node_1;
        (inter_node->num_child) ++;
        root->children[i] = inter_node;
        node_1->parent = inter_node;
        node_1 = node_1->parent;
    }

    if(node_2->t_label == - 1){
        Node *inter_node= build_basic_node_with_list();
        (*tid)++;
        inter_node->t_label = *tid;
        inter_node->parent = node_2->parent;
        inter_node->children[0] = node_2;
        (inter_node->num_child) ++;
        root->children[j] = inter_node;
        node_2->parent = inter_node;
        node_2 = node_2->parent;
    }

    // If already intermediate nodes, switch labels.
    if(node_1->t_label < node_2->t_label){
        node_2->t_label = node_1->t_label;
    } else{
        node_1->t_label = node_2->t_label;
    }
}

    \end{lstlisting}
\caption{General Merge functions}
\label{fig:Gerenal merge function}
\end{figure}



\begin{figure}[H]
    \begin{lstlisting}[
        language=C,
        numbers=left,
        basicstyle= \tiny,
        stepnumber=1,
        numbersep=5pt,
        xleftmargin=1.5em,
        frame=none
    ]
void rigorous_replacement_check(Node *replacer, Node *replacee, Node *dup_tree, int pos, int *res){

    //if at any point res become 0, stop execution immediately
    if (!(*res)){
        return;
    }

    // Check if you are replacing single char so you can compare char
    // as terminal do not have a tid ( implementation diff )
    int terminal_replacee = 0;

    if (replacee->t_label == -1){
        terminal_replacee = 1;
    }

    // Flags to redue calls to the oracle
    // Extra oracles occur due to recursion.
    int forward = 1;

    // Looping through all the nodes in t0
    for ( int i = pos; i < dup_tree->num_child;  i++){

        Node *cur = dup_tree->children[i];

        // if it is a terminal replacee and no the correct 1
        // right now. Continue
        if (terminal_replacee){
            if (cur->character != replacee->character){
                continue;
            }
        }

        // perform the swap.
        dup_tree->children[i] = replacer;
        advanced_replacement_check(replacer, replacee, dup_tree, i + 1, res);
        if(forward){
            // call to oracle then
            // if (call to oracle) -> pass : *res = 0;
            char *buffer = calloc(1, sizeof(char));
            concatenate(dup_tree, &buffer);
            *res = parse_string(buffer);
            //printf("Printing buffer: %s and %d.\n",buffer, *res);
            free(buffer);
            forward = 0;

        }
        dup_tree->children[i] = cur;
        // case where 1 of the candidate string is invalid, so return.
        if(!*res){
            return;
        }
        concact_and_print(dup_tree);
        advanced_replacement_check(replacer, replacee, dup_tree, i + 1, res);

    }

    *res = 1;
}
    \end{lstlisting}
\caption{Rigorous replacement check}
\label{fig:Rigorous replacement}
\end{figure}