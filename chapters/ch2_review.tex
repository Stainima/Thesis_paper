\chapter{GENERAL REVIEW OF LITERATURE}

\subsection{What is ARVADA?}

\subsubsection{Introcution}

ARVADA is an algorithm, published in \enquote{Learning Highly Recursive Input Grammars} \cite{kulkarniLearningHighlyRecursive2021} at the University of California, Berkeley in 2021. It is an algorithm designed to learn context-free grammars from a set of positive examples and a Boolean-valued oracle $\mathcal{O}$. Starting from an initially flat parse trees, ARVADA repeatedly utilizes two specialised operations, \textbf{bubbling} and \textbf{merging}, to add structure to these trees. Which is used to extract the smallest set of context-free grammar possible that accommodates for all the given examples. The algorithm aim to generalise the language as much as possible, while not over generalising the language accepted by the $\mathcal{O}$.

ARVADA, similar to GLADE \cite{bastaniSynthesizingProgramInput}, works assuming a black-box oracle $\mathcal{O}$. Meaning ARVADA has no access or knowledge about how the oracle works, but only can see the Boolean value return from the $\mathcal{O}$. 

\subsubsection{Walktrough}

\subsection{What are Grammars?}

Grammars both in the natural and artifical language can be defined as a set of rules by which valid sentences in a language are constructed \cite{jiangFormalGrammarsLanguages}. Beginning with a start symbol, which is a single non-termial, production rules are applied sequentially adding alphabet from the grammar to generate a string which is valid in the grammar.

\subsection{Further Quesitons}

What are parsers?

What are context free grammar?

Why do a replication study?

\subsection{Why C?}

In the original study \cite{kulkarniLearningHighlyRecursive2021}, the ARVADA algorithm was implemented in Python. When compared to GLADE \cite{bastaniSynthesizingProgramInput}, which was implemented in Java, ARVADA exhibited a slower average runtime across all benchmarks. As stated in the study, this could be attributed to the natural runtime disadvantage of Python compared to Java.

\vspace{\baselineskip}
In a comparative study, \enquote{A Pragmatic Comparison of Four Different Programming Languages} \cite{aliPragmaticComparisonFour2021}, it was found that if speed and efficiency were important in an implementation, C was a better options compared to Python. C, being a mid-level, statically typed, structured language that runs under a compiler, will always be faster than a dynamic language run under an interpreter such as Python \cite{kumarPythonLanguageComparison2022}. Along with being a structured language, C also comes with only essential features. These limited features contribute to its efficiency but also introduce a higher level of complexity compared to Python \cite{aliPragmaticComparisonFour2021}\cite{kumarPythonLanguageComparison2022}.

\vspace{\baselineskip}
Hence, with the aim of replicating and improving upon the runtime bottleneck presented by Python—while acknowledging the rise in complexity C introduces compared to Python—C was chosen as the language of implementation.

Why ARVADA / Problem Statement?

Why is learning highly input grammar important?

What is GLADE?

What are other Similar works done?

What is the work done in this field after ARVADA?



